\documentclass{article}
\textwidth=6in
\hoffset=0in
\voffset=0in


\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}

\usepackage{tikz}
\usetikzlibrary{automata, arrows}
\tikzset{initial text={}}

\usepackage{pifont}
\usepackage{amssymb}
\usepackage{gensymb}
\usepackage{ngerman}
\usepackage[ampersand]{easylist}
\usepackage{xcolor}

% needs to be updated
\author{Max Springenberg, 177792}
\title{\
    GTI "Ubungsblatt 12\\
    Tutor: Marko Schmellenkamp\\
    ID: MS1\\
    "Ubung: Mi 16-18
    }
\setcounter{section}{12}
\date{}

% custom commands
% \Theta \Omega \omega
\newcommand{\tab}{\null\ \qquad}
\newcommand{\gap}{\null\ \\ \\}
\newcommand{\da}{\downarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\lA}{\leftarrow}
\newcommand{\ra}{\rightarrow}
\newcommand{\rA}{\rightarrow}
\newcommand{\LA}{\Leftarrow}
\newcommand{\RA}{\Rightarrow}
\newcommand{\Ra}{\Rightarrow}
\newcommand{\Lra}{\Leftrightarrow}
\newcommand{\ue}{\infty}
\newcommand{\eps}{\epsilon}
\newcommand{\task}[1]{\textbf{#1} \gap}
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}
\newcommand{\degr}{\null \degree}
\newcommand{\error}[1]{\colorbox{red}{\task{FEHLER:}\\#1}}
\newcommand{\correction}[1]{\colorbox{green}{\task{KORREKTUR:}\\#1}}
\newcommand{\mdef}{\overset{\text{def}}{=}}
\newcommand{\rao}[1]{\overset{#1}{\rightarrow}}
\newcommand{\automaton}[1]{
    \begin{tikzpicture}
    #1
    \end{tikzpicture}
    }
\newcommand{\nd}[4]{
    \node[#1](#2)at(#3){#4};
    }
\newcommand{\dm}{\mathbin{\scriptstyle\dot{\smash{\textstyle-}}}}
\newcommand{\s}{\rhd}
\renewcommand{\u}{\underline}
\renewcommand{\phi}{\varphi}


% content
\begin{document}
% title page
\maketitle
\newpage
% actual paper

% A1
\subsection\

% a)
\subsubsection\
z.z.: $G_{RAPH}I_{SOMORPHIE} \in NP$\\
\\
Nach Vorlesung hatten wir die Zugeh"origkeit von Problemen wie folgt definiert:\\
\begin{enumerate}
    \item es existiert ein Suchraum von L"osungen
    \item jede L"osung ist polynomiell gro"s in ihrer Eingabe
    \item jede L"osung kann in polynomieller Zeit "uberpr"uft werden
\end{enumerate}
\gap
Der Suchraum umfasst Bijektionen von Graph $G$ nach $G'$, oder TUringmaschinen
    die eine Bijektion umsetzten.\\
\\
Diese Funktionen, oder auch Turingmaschinen sind polynomiell in ihrer 
    Eingabegr"o"se, da f"ur jede Kante und jeden Knoten je ein Fall, oder ein
    Zustand ben"otigt wird, der die Jeweiligen variablen umbenennt.\\
Insbesondere ergibt sich daraus, dass Die Funktion oder auch TM durch den Betrag
    an Kanten und Knoten mit $O(|V|+E|)$ eingeschr"ankt werden kann.\\
\\
Der Test eines L"osungskandidaten kann wie folgt getestet werden.\\
$G = (V,E), G' = (V',E')$\\
\begin{enumerate}
    \item $marked = \emptyset$
    \item FOR $v \in V$ DO
    \item \tab $marked = marked \cup \{v\}$
    \item \tab FOR $u \in adj(v) \cap marked$ DO
    \item \tab \tab IF $\neg ( f(u) \in adj(f(v)) )$ THEN
    \item \tab \tab \tab return false
    \item \tab \tab $marked = marked \cup \{u\}$
    \item $marked = \emptyset$
    \item FOR $v' \in V'$ DO
    \item \tab $marked = marked \cup \{v\}$
    \item \tab FOR $u' \in adj(v') \cap marked$ DO
    \item \tab \tab IF $\neg ( f^{-1}(u) \in adj(f^{-1}(v)) )$ THEN
    \item \tab \tab \tab return false
    \item \tab \tab $marked = marked \cup \{u\}$
    \item return tr"u
\end{enumerate}
Der algorithmus testet f"ur jeden Knoten, allen adjazenten Knoten in $adj$ 
    auch nach anwenden der Bijektion noch adjazent sind. Und umgekehrt.\\
Wenn dies der Fall ist wurde die Kantenrelation eingehalten sonst nicht.\\
Die umkehrung der codierung einer bijektiven Funktion, oder einer TM 
    kann polynomiell berechnet werden.\\
Insbesondere ist der Test durch die Anzahl an Kanten begrenzt.\\
Der Algorithmus hat also eine Laufzeitschranke von $O(|E|)$.\\

% b)
\subsubsection\
Eine aussagenlogische Formel $\phi$ bestehe aus $k$ Klauseln und $n$ Literalen,
    mit $k,n \in \mathbb{N}$\\
Da eine Klausel aus Verorderungen besteht ist diese Bereits erf"ullt, sobald
    eine Belegung eine in der Klausel enthaltenem Variable so belegt, dass das
    Literal positiv ist, ist die KLausel erf"ullt.\\
Bereits erf"ullte Klauseln sind nicht mehr ausschlaggeben f"ur die 
    Erf"ullbarkeit von $\phi$.\\
\\
%Wir betrachten die Funktion $lit(i,j)$, die zu jeder Variable $x_i$ alle Literale
%    aus der Klausel $\psi_j$ ausgibt, die sie enthalten.\\
%Ferner nehmen wir an, dass $\alpha$ auf einer menge $L_X$ von Literalen
%    ausgef"uhrt werden kann und $\alpha(L_X)$ dann nur noch bin"are Werte
%    enth"alt. Ferner gebe die Funktion $any(M)$, genau dann 1 aus, wenn die ihr 
%    "ubergebene Menge $M$ mindestens einmal 1 enth"alt und 0 sonst.\\
%$D(f)$ ordne der Funktion $f$ ihren Definitionsbereich zu.\\
%$filter(\psi,M)$ Sie eine Funktion, die aus $\psi$ alle Literale aus 
%    der Menge $M$ entfernt.\\
%\gap
%Aus dieser Erkenntnis folgt die Funktion $f$ mit:\\
%$
%\phi = \psi_1 \land \ldots \land \psi_k\\
%f(\phi, \alpha) = \phi'\\
%\\
%\phi' = \bigvee_{k' \in K_{\phi'}} \psi_{k'}\\
%\\
%% alle durch alpha erf"ullten Klauseln werden rausgeschmissen
%(i) K_{\phi'} = \{1, \ldots, k\} 
%    - \{ 
%        j \in \{1,\ldots,k\}
%        | \exists i \in \{1,\ldots,n\}: any(\alpha(lit(i,j)))=1
%    \}\\
%% phi' frei von variablen aus dem Wertebereich von alpha
%(ii) \forall k' \in K_{\phi'}, i \in \{1, \ldots, n\}: 
%    \psi_{k'} = filter(\psi_k, lit(i,k'))\\
$f$ Sei gegeben durch \[
    f(\phi, \alpha) = \phi'
    \]
Wobei $\phi'$ (i) nur Klauseln aus $\phi$ enth"alt, 
    die unter Belegung $\alpha$ nicht
    schon erf"ullt sind 
    und (ii) deren Klauseln nur noch Variablen 
    enthalten, die nicht im Definitionsbereich von $\alpha$ liegen.\\



\newpage
% A2
\subsection\

% a)
\subsubsection\
Betrachte $I=\{2,3,4\}$ mit:\\
$
\bigcup_{i \in I} S_i = \{a,b,c,d\}\\
S_2 \cap S_3  = \emptyset\\
S_2 \cap S_4  = \emptyset\\
S_3 \cap S_4  = \emptyset\\
$\\
$I$ ist eine entsprechende Indexmenge.\\

% b)
\subsubsection\

\end{document}
