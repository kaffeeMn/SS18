\documentclass{article}
\textwidth=6in
\hoffset=0in
\voffset=0in


\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}

\usepackage{tikz}
\usetikzlibrary{automata, arrows}
\tikzset{initial text={}}

\usepackage{pifont}
\usepackage{amssymb}
\usepackage{gensymb}
\usepackage{ngerman}
\usepackage[ampersand]{easylist}

% needs to be updated
\author{Max Springenberg, 177792}
\title{\
    GTI "Ubungsblatt 8\\
    Tutor: Marko Schmellenkamp\\
    ID: MS1\\
    "Ubung: Mi 16-18
    }
\setcounter{section}{8}
\date{}

% custom commands
% \Theta \Omega \omega
\newcommand{\tab}{\null\ \qquad}
\newcommand{\gap}{\null\ \\ \\}
\newcommand{\da}{\downarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\lA}{\leftarrow}
\newcommand{\ra}{\rightarrow}
\newcommand{\rA}{\rightarrow}
\newcommand{\LA}{\Leftarrow}
\newcommand{\RA}{\Rightarrow}
\newcommand{\ue}{\infty}
\newcommand{\eps}{\epsilon}
\newcommand{\task}[1]{\textbf{#1} \gap}
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}
\newcommand{\degr}{\null \degree}
\newcommand{\error}{\task{FEHLER:}}
\newcommand{\correction}{\task{KORREKTUR:}}
\newcommand{\mdef}{\overset{\text{def}}{=}}
\newcommand{\rao}[1]{\overset{#1}{\rightarrow}}
\newcommand{\automaton}[1]{
    \begin{tikzpicture}
    #1
    \end{tikzpicture}
    }
\newcommand{\nd}[4]{
    \node[#1](#2)at(#3){#4};
    }
\newcommand{\dm}{\mathbin{\scriptstyle\dot{\smash{\textstyle-}}}}
\newcommand{\s}{\rhd}
\renewcommand{\u}{\underline}


% content
\begin{document}
% title page
\maketitle
\newpage
% actual paper

% A1
\subsection\

% a)
\subsubsection\
\task{(i)}
$f(1) = \bot$\\ %\Bottom\\
$x_4$ ist bei $x_1 = 1$ nach Ablauf des ersten WHILE-Programma (3-11) mit:\\$
x_4 := x_4 \dm 1 = 1, \tab x_1 := x_1 \dm 1 = 0\\
$echt gr"o"ser 0, damit endet das Folgende WHILE-Programm (12-14) nie.\\
\\
$f(2) = 4$\\

\gap
\task{(ii)}
Da das WHILE-Programm (12-14) nur dann endet, bzw. umgangen wird, wenn zuvor
    $x_4$ auf 0 gesetzt wurde. Muss das WHILE-Programm (3-11) mindestens
    zwei mal durchlaufen werden, da $x_4$ initial auf 2 gesetzt und in 
    diesem dekrementiert wird.\\
Die Funktion $f_P$ ergibt sich dadurch zu:\\
$f_P(n) = \begin{cases}
    2^n, n \geq 2\\ 
    \bot, \text{sonst}\\
\end{cases}$\\
\gap
Werte- und Definitionsbereich sind wie folgt definiert.\\
$
D(f) = \{n \in \mathbb{N}_0 | f(n) \neq \bot\}\\
W(f) = \{n \in \mathbb{N}_0 | \exists m \in \mathbb{N}_0 : f(m) = n\}\\
$
Aus den Definitionen und der Funktion $f_P$ ergeben sich $D(f_P), W(f_P)$ zu:\\
$
D(f_P)  = \{n \in \mathbb{N}_0 | f_P(n) \neq \bot\}
        = \{n \in \mathbb{N}_0 | n \geq 2\}\\
W(f_P)  = \{n \in \mathbb{N}_0 | \exists m \in \mathbb{N}_0 : f_P(m) = n\}
        = \{2^n | n \in \mathbb{N}_0 \land n \geq 2\} \cup \{\bot\}\\
$

% b)
\subsubsection\
Konstruktionsidee:\\
\begin{enumerate}
    \item rechne $x_{diff} = x_2 \dm x_1$\\
    \item wenn $x_{diff} = 0$ gebe $x_1$ aus\\
    \item sonst gebe $x_2$ aus\\
    \item halte an.\\
\end{enumerate}\ \\
Dieses Vorgehen gibt immer den maximalen Wert aus, da f"ur den Fall 
    $x_1 \geq x_2$ die Differenz $x_{diff}$ mit $\dm$ gleich 0 ist und $x_1$ 
    ausgegeben wird und f"ur den Fall $x_1 < x_2$ die Differenz gr"o"ser 0 ist
    und $x_2$ ausgegeben wird.\\
\\
Da nun Diese Operationen nicht genau so mit unserer Syntax f"ur GOTO-Programme
    kompatibel sind m"ussen wir Anpassungen vornehmen.\\
So brauchen wir:\\
Eine Variable $x_3$ die $x_1$ kopiert und "uber die das 
    Subtrahieren von $x_1$ simuliert werden kann.\\
Eine Variable $x_4$ die die Funktion von $x_{diff}$ "ubernimmt und initial 
    gleich $x_2$ ist.\\
Ferner ben"otigen wir eine Variable $x_5$ f"ur Schleifenspr"unge.\\
\gap
Daraus ergibt sich das folgende GOTO-Programm $P$:\\
$
\begin{array}{ll}
    1:  & x_3 := x_1;\\
    2:  & x_4 := x_2;\\
    3:  & x_5 := 1;\\
    \\
    4:  & $IF $ x_3 = 0 $ THEN GOTO $ 8;\\
    5:  & x_3 := x_3 \dm 1;\\
    6:  & x_4 := x_4 \dm 1;\\
    7:  & $IF $ x_5 = 1 $ THEN GOTO $ 4;\\
    \\
    8:  & $IF $ x_4 = 0 $ THEN GOTO $ 10;\\
    9:  & x_1 := x_2;\\
    \\
    10: & HALT
\end{array}\\
$\\
(4-6) simulieren $x_{diff} = x_2 - x_1$ und der Ausgabewert $x_1$ wird nur dann
    auf $x_2$ gesetzt, wenn $x_{diff} > 0$ gilt.\\

\newpage
% A2
\subsection\

% a)
\subsubsection\
Betrachte:\\
$
w \mdef bab\\
\\
\text{Ersten 10 Konfigurationen:}\\
(q_b,(\eps,\s,bab)) \vdash (q_b, (\s,b,ab))\\
                    \vdash (q_r, (\s \u{b},a,b))\\
                    \vdash (q_r, (\s \u{b}a,b,\eps))\\
                    \vdash (q_r, (\s \u{b}ab,\sqcup,\eps))\\
                    \vdash (q_l, (\s \u{b}a,b,\u{b}))\\
                    \vdash (q_l, (\s \u{b},a,b\u{b}))\\
                    \vdash (q_l, (\s ,\u{b},ab\u{b}))\\
                    \vdash (q_l, (\eps ,\s,\u{b}ab\u{b}))\\
                    \vdash (q_b, (\s ,\u{b},ab\u{b}))\\
\\
\text{Erste Konfiguration in $q_c$:}\\
(q_c, (\s\u{b}a\u{b}\u{b},\u{b}, \sqcup))\\
\\
\text{Haltekonfiguration f"ur Eingabe $w$}\\
(h, (\eps, \s, babbb))\\
$

% b)
\subsubsection\
Bedeutung der Zust"ande:\\
\task{$q_b$}
$q_b$ lie"st den gesamten String von links nach rechts, bis er endet, bzw. ein 
    $\sqcup$ auftritt, oder ein b gelesen wird.\\
Wenn ein b gelesen wird, so wird dieses durch ein markiertes b ($\u{b}$)
    Â§ersetzt und in den Zustand $q_l$ gewechselt.\\
Wenn ein $\sqcup$ gelesen wird, hat der String keine unmarkierten b mehr und es
    wird in den Zustand $q_c$ gewechselt.\\
\gap
\task{$q_c$}
$q_c$ liest den gesamten String von links nach rechts und ersetzt alle 
    markierten b mit unmarkierten, bis das Startsymbol erreicht wird.\\
In diesem Fall wird aufgeh"ort den Lesekopf zu bewegen und in den Zustand h
    gewechselt.\\
\gap
\task{$q_r$}
$q_r$ verschiebt den Lesekopf solange nach rechts, bis der String endet, bzw.
    ein $\sqcup$ gelesen wird.\\
Dann wird dieses durch ein markiertes b ersetzt, bzw. ein markiertes b an den
    String hinten angehangen.\\
\gap
\task{$q_l$}
$q_l$ verschiebt den Lesekopf solange nach links, bis das Startsymbol gelesen
    wird.\\
Dann wird in den Zustand $q_b$ gewechselt.\\
\gap
\task{$h$}
Im Zustand h h"alt die Touringmaschine.\\
\gap
Aus der Bedeutung der Zust"ande geht hervor, dass:\\
Die Touringmaschine jedes b markiert und anschlie"send ein markiertes b an den
    String hinten anh"angt, bis es keine unmarkierten b mehr gibt.\\
Abschlie"send werden alle markierten b durch normale b ersetzt und die TM h"alt.\\
Da nach endlichen Operationen bei endlichen Eingaben alle b markiert worden sind
    h"alt die TM auch f"ur alle Eingaben aus $\{a,b\}^*$ und wei"st damit keine
    Definitionsl"ucken auf.\\
\\
F"ur die Funktion $f_M$ der TM bedeutet das, dass die Touring maschine aus einem
    Wort $w \in \{a,b\}^*$ ein Wort $v \in \{a,b\}$, das aus w konkateniert mit
    $n=\#_b(w)$ b besteht
    , also der Form $v = wb^{n=\#_b(w)}$, macht.\\
Dadurch ergibt sich dann auch die Funktion $f_M$ zu:\[
    f_M(w) = wb^{n=\#_b(w)}
    \]

\newpage
% A3
\subsection\

% a)
\subsubsection\
Eingabewort der Form: $u\$v\$$, mit $|u| = |v|$\\
\\
Konstruktionsidee:\\
\begin{enumerate}
    \item betrachte das erste unmarkierte Zeichen aus u und gleiche ab, 
        ob das erste unmarkierte Zeichen aus v gleich diesem ist.
        Markiere die beiden Zeichen\\
    \item falls nein h"ange an das Wort ein $a$\\
    \item gehe zur"uck zum Anfang des Wortes und mache weiter bei 1, bis 
        alles Markiert wurde. Dann mache die Markierungen r"ueckg"angig und 
        halte an.\\
\end{enumerate}\ \\
Das Markieren und "uberlesen der markierten Zeichen aus $u$ erfolgt in $s$, dann
    wird "uber $u_\sigma$ ein $\sigma \in \{a,b\}$ gemerkt und nachdem v in
    $u_\sigma v$ erreicht wurde alle markierten Zeichen "uberlesen und
    verglichen, ob das erste unmarkierte Zeichen gleich $\sigma$ ist.\\
Falls ja wird zur"uck gegangen. Sonst wird ein $a$ angehangen und dann zur"uck
    gegangen. Das anh"angen eines $a$ erfolgt "uber $add$, das Zur"ucklaufen
    "uber $l$.\\
Das r"uckg"angigmachen der Markierung erfolgt "uber die Zust"ande 
    $\{l', unmark\}$, nachdem alles markiert wurde.\\
Das Halten darauf "uber den Zustand $h$.\\
Des weiteren muss die Syntax der eingabe nach dem Trennsymbol $\$$ gecheckt 
    werden, von 
    $|u| = |v|$ kann nach Aufgabe ausgegangen werden.\\
F"ur das Syntax-checking, ob das eingegebene Wort auch mit $\$$ endet, ben"otigen
    wir die Zust"ande $\{
    syntax
    ,syntax'
    ,syntax''
    \}$\\
\\
Eine m"ogliche L"osung w"are die TM $M = (Q, \Gamma, \delta, s)$, mit:$\\
Q = \{
,s
,u_a
,u_b
,u_a v
,u_b v
,add
,l
,l'
,unmark
,syntax
,syntax'
,syntax''
,h
\}\\
\Gamma = \{a,b,\$,\s,\sqcup,\u{a},\u{b}\}\\
\delta \text{ nach Aufgabenstellung nicht formal zu spezifizieren.}\\
s = \s\\
$, mit dem zugeh"origem Diagramm:\\
\automaton{
    \nd{initial, state}{s}      {0,0}   {$s$}
    \nd{state}{ua}              {4,4}   {$u_a$}
    \nd{state}{ub}              {4,-4}  {$u_b$}
    \nd{state}{uav}             {8,4}   {$u_a v$}
    \nd{state}{ubv}             {8,-4}  {$u_b v$}
    \nd{state}{syntax}          {8,0}   {$syntax$}
    \nd{state}{syntax'}         {6,2}   {$syntax'$}
    \nd{state}{syntax''}        {6,-2}  {$syntax''$}
    \nd{state}{add}             {11,0}  {$add$}
    \nd{state}{l}               {4,0}   {$l$}
    \nd{state}{l'}              {0,-2}  {$l'$}
    \nd{state}{unmark}          {0,-5}  {$unmark$}
    \nd{state}{h}               {0,-8} {$h$}
    \path
        (s)
            edge [->, loop above] node {$\begin{array}{l}
                                            \s : \s, \ra\\
                                            \u{a} : \u{a}, \ra\\
                                            \u{b} : \u{b}, \ra\\
                                        \end{array}$} (s')
            edge [->, left] node {$a:\u{a}, \ra$}(ua)
            edge [->, left] node {$b:\u{b}, \ra$}(ub)
            edge [->, left] node {$\$:\$, \la$}(l')
        (ua)
            edge [->, loop above] node {$\begin{array}{l}
                                            a : a, \ra\\
                                            b : b, \ra\\
                                        \end{array}$} (ua)
            edge [->, above] node {$\$:\$, \ra$}(uav)
        (ub)
            edge [->, loop below] node {$\begin{array}{l}
                                            a : a, \ra\\
                                            b : b, \ra\\
                                        \end{array}$} (ub)
            edge [->, below] node {$\$:\$, \ra$}(ubv)
        (uav)
            edge [->, loop above] node {$\begin{array}{l}
                                            \u{a} : \u{a}, \ra\\
                                            \u{b} : \u{b}, \ra\\
                                        \end{array}$} (ub)
            edge [->, left] node {$a:\u{a}, \ra$}(syntax')
            edge [->, right] node {$b:\u{b}, \ra$}(add)
        (ubv)
            edge [->, loop below] node {$\begin{array}{l}
                                            \u{a} : \u{a}, \ra\\
                                            \u{b} : \u{b}, \ra\\
                                        \end{array}$} (ub)
            edge [->, right] node {$b:\u{b}, \ra$}(syntax'')
            edge [->, right] node {$a:\u{a}, \ra$}(add)
        (add)
            edge [->, loop right] node {$\begin{array}{l}
                                            a : a, \ra\\
                                            b : b, \ra\\
                                        \end{array}$} (add)
            edge [->, above] node {$\$: \$, \ra$} (syntax)
        (syntax)
            edge [->, loop above] node {$\begin{array}{l}
                                            a : a, \ra\\
                                        \end{array}$}(syntax)
            edge [->, above] node {$\sqcup : a, \la$} (l)
        (syntax')
            edge [->, loop left] node {$\begin{array}{l}
                                            a : a, \ra\\
                                            b : b, \ra\\
                                        \end{array}$} (syntax')
            edge [->, right] node {$\$: \$, \la$} (l)
        (syntax'')
            edge [->, loop right] node {$\begin{array}{l}
                                            a : a, \ra\\
                                            b : b, \ra\\
                                        \end{array}$} (syntax'')
            edge [->, right] node {$\$: \$, \la$} (l)
        (l)
            edge [->, loop below] node {$\begin{array}{l}
                                            \u{a} : \u{a}, \la\\
                                            \u{b} : \u{b}, \la\\
                                            a : a, \la\\
                                            b : b, \la\\
                                            \$ : \$, \la\\
                                        \end{array}$} (add)
            edge [->, above] node {$\s : \s, \ra$} (s)
        (l')
            edge [->, loop left] node {$\begin{array}{l}
                                            \u{a} : \u{a}, \la\\
                                            \u{b} : \u{b}, \la\\
                                        \end{array}$} (add)
            edge [->, left] node {$\s : \s, \ra$} (unmark)
        (unmark)
            edge [->, loop left] node {$\begin{array}{l}
                                            \u{a} : a, \ra\\
                                            \u{b} : b, \ra\\
                                            \$ : \$, \ra\\
                                        \end{array}$} (add)
            edge [->, left] node {$\sqcup : \sqcup, \da$} (h)
    ;}\\
\gap
Alle nicht angegebenen Transitionen f"uhren zum halten, bzw. verwerfen der Eingabe.\\

% b)
\subsubsection\
Es m"usste jedes Zeichen gleich sein und ferner keine $a$ angehangen werden.\\
Der Zustand $add$ und alle Transitionen inzident zu diesem k"onnen entfernt 
    werden.\\
Ferner f"uhren nun alle Transitionen, die zuvor nach $add$ f"uhrten nun nach 
    $nein$ und statt markieren bleibt der Lesekopf stehen, da bereits ein 
    ungleiches Zeichen ausreicht, damit das Wort nicht in der Sprache ist.\\
Zudem muss nun lediglich akzeptiert und nichtmehr demakiert werden, also 
    k"onnen $\{l', unmark, h\}$ 
    und ihre inzidenten Transitionen auch gel"oscht und durch einen 
    Zustand $ja$ ersetzt werden.\\
Die resultierende TM h"atte damit das zugeh"orige Diagramm:\\
\automaton{
    \nd{initial, state}{s}      {0,0}   {$s$}
    \nd{state}{ua}              {4,4}   {$u_a$}
    \nd{state}{ub}              {4,-4}  {$u_b$}
    \nd{state}{uav}             {8,4}   {$u_a v$}
    \nd{state}{ubv}             {8,-4}  {$u_b v$}
    \nd{state}{syntax'}         {6,2}   {$syntax'$}
    \nd{state}{syntax''}        {6,-2}  {$syntax''$}
    \nd{state}{add}             {11,0}  {$nein$}
    \nd{state}{l}               {4,0}   {$l$}
    \nd{state}{l'}              {0,-2}  {$ja$}
    \path
        (s)
            edge [->, loop above] node {$\begin{array}{l}
                                            \s : \s, \ra\\
                                            \u{a} : \u{a}, \ra\\
                                            \u{b} : \u{b}, \ra\\
                                        \end{array}$} (s')
            edge [->, left] node {$a:\u{a}, \ra$}(ua)
            edge [->, left] node {$b:\u{b}, \ra$}(ub)
            edge [->, left] node {$\$:\$, \ra$}(l')
        (ua)
            edge [->, loop above] node {$\begin{array}{l}
                                            a : a, \ra\\
                                            b : b, \ra\\
                                        \end{array}$} (ua)
            edge [->, above] node {$\$:\$, \ra$}(uav)
        (ub)
            edge [->, loop below] node {$\begin{array}{l}
                                            a : a, \ra\\
                                            b : b, \ra\\
                                        \end{array}$} (ub)
            edge [->, below] node {$\$:\$, \ra$}(ubv)
        (uav)
            edge [->, loop above] node {$\begin{array}{l}
                                            \u{a} : \u{a}, \ra\\
                                            \u{b} : \u{b}, \ra\\
                                        \end{array}$} (ub)
            edge [->, left] node {$a:\u{a}, \ra$}(syntax')
            edge [->, right] node {$b:\u{b}, \ra$}(add)
        (ubv)
            edge [->, loop below] node {$\begin{array}{l}
                                            \u{a} : \u{a}, \ra\\
                                            \u{b} : \u{b}, \ra\\
                                        \end{array}$} (ub)
            edge [->, right] node {$b:\u{b}, \ra$}(syntax'')
            edge [->, right] node {$a:\u{a}, \ra$}(add)
        (syntax')
            edge [->, loop left] node {$\begin{array}{l}
                                            a : a, \ra\\
                                            b : b, \ra\\
                                        \end{array}$} (syntax')
            edge [->, right] node {$\$: \$, \la$} (l)
        (syntax'')
            edge [->, loop right] node {$\begin{array}{l}
                                            a : a, \ra\\
                                            b : b, \ra\\
                                        \end{array}$} (syntax'')
            edge [->, right] node {$\$: \$, \la$} (l)
        (l)
            edge [->, loop below] node {$\begin{array}{l}
                                            \u{a} : \u{a}, \la\\
                                            \u{b} : \u{b}, \la\\
                                            a : a, \la\\
                                            b : b, \la\\
                                            \$ : \$, \la\\
                                        \end{array}$} (add)
            edge [->, above] node {$\s : \s, \ra$} (s)
        (l')
    ;}\\
\end{document}
