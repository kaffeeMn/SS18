
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>Mitschriften EDV &#8212; noname  documentation</title>
    <link rel="stylesheet" href="_static/guzzle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
  
   

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="index.html">noname  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <h2>Contents</h2>
    <div class="sidebar-localtoc">
      <ul>
<li><a class="reference internal" href="#">Mitschriften EDV</a><ul>
<li><a class="reference internal" href="#table-of-contents">Table of Contents</a></li>
<li><a class="reference internal" href="#block-b">Block B</a><ul>
<li><a class="reference internal" href="#pipilines">Pipilines</a><ul>
<li><a class="reference internal" href="#d">2D</a></li>
<li><a class="reference internal" href="#id1">3D</a></li>
</ul>
</li>
<li><a class="reference internal" href="#farben">Farben</a><ul>
<li><a class="reference internal" href="#cie">CIE</a></li>
<li><a class="reference internal" href="#rgb">RGB</a></li>
<li><a class="reference internal" href="#hsv">HSV</a></li>
<li><a class="reference internal" href="#cmy">CMY</a></li>
</ul>
</li>
<li><a class="reference internal" href="#d-bilderzeugung">2D Bilderzeugung</a><ul>
<li><a class="reference internal" href="#koordinatensysteme">Koordinatensysteme</a></li>
<li><a class="reference internal" href="#transformationen">Transformationen</a></li>
<li><a class="reference internal" href="#transformationsmatrix">Transformationsmatrix</a></li>
<li><a class="reference internal" href="#clipping">Clipping</a></li>
<li><a class="reference internal" href="#verrasterung">Verrasterung</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id3">3D-Bilderzeugung</a><ul>
<li><a class="reference internal" href="#transformation">Transformation</a></li>
<li><a class="reference internal" href="#beleuchtung">Beleuchtung</a></li>
<li><a class="reference internal" href="#projektion">Projektion</a></li>
<li><a class="reference internal" href="#sichtbarkeitsberechnung">Sichtbarkeitsberechnung</a><ul>
<li><a class="reference internal" href="#moegliche-pruefungsfragen-b">Moegliche Pruefungsfragen B</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#block-c">Block C</a><ul>
<li><a class="reference internal" href="#lagrange-multiplikatoren">Lagrange-Multiplikatoren</a></li>
<li><a class="reference internal" href="#ausgleichsebenen">Ausgleichsebenen</a><ul>
<li><a class="reference internal" href="#optmierungsproblem">Optmierungsproblem</a></li>
</ul>
</li>
<li><a class="reference internal" href="#erkenntniss">Erkenntniss</a></li>
<li><a class="reference internal" href="#aufbau">Aufbau</a></li>
<li><a class="reference internal" href="#anlernen">Anlernen</a></li>
<li><a class="reference internal" href="#vektorquantisierung">Vektorquantisierung</a><ul>
<li><a class="reference internal" href="#k-vektorquantisierung">k-Vektorquantisierung</a></li>
<li><a class="reference internal" href="#id4">Vektorquantisierung</a></li>
<li><a class="reference internal" href="#aufteilung">Aufteilung</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hyper-octree-vektorquantisierung">Hyper-Octree-Vektorquantisierung</a></li>
<li><a class="reference internal" href="#median-schnitt-vektorquantisierung">Median-Schnitt-Vektorquantisierung</a></li>
<li><a class="reference internal" href="#k-mittelwert-clustering">k-Mittelwert-Clustering</a><ul>
<li><a class="reference internal" href="#moeglichkeiten-zur-verbesserung">Moeglichkeiten zur Verbesserung</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hierarchisches-clustering">Hierarchisches CLustering</a></li>
<li><a class="reference internal" href="#dichtebasiertes-clustering">Dichtebasiertes Clustering</a></li>
</ul>
</li>
<li><a class="reference internal" href="#block-d">Block D</a><ul>
<li><a class="reference internal" href="#hypergraph">Hypergraph</a></li>
<li><a class="reference internal" href="#topologie-form-metrik">Topologie-Form-Metrik</a><ul>
<li><a class="reference internal" href="#topologie">Topologie</a></li>
<li><a class="reference internal" href="#form">Form</a></li>
<li><a class="reference internal" href="#metrik">Metrik</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hierachischer-ansatz">Hierachischer Ansatz</a></li>
<li><a class="reference internal" href="#sichtbarkeitsansatz">Sichtbarkeitsansatz</a></li>
<li><a class="reference internal" href="#verfeinerungsansatz">Verfeinerungsansatz</a></li>
<li><a class="reference internal" href="#allgorithmus-von-sugiyama">Allgorithmus von Sugiyama</a></li>
<li><a class="reference internal" href="#einfacher-algorithmus-zum-zeichnen">Einfacher Algorithmus zum Zeichnen</a></li>
<li><a class="reference internal" href="#aestetikkriterien-fuer-binaerbaeume">Aestetikkriterien fuer Binaerbaeume</a><ul>
<li><a class="reference internal" href="#algorithmus-von-reingold-und-tilford">Algorithmus von Reingold und Tilford</a><ul>
<li><a class="reference internal" href="#horizontal-vertikal-zeichnen">Horizontal-Vertikal Zeichnen</a></li>
<li><a class="reference internal" href="#zeichnen-durch-rekurives-drehen">Zeichnen durch rekurives drehen</a></li>
<li><a class="reference internal" href="#vereinfachen-von-polygonzuegen">Vereinfachen von Polygonzuegen</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#min-version">min-# Version</a></li>
<li><a class="reference internal" href="#fehlermasse">Fehlermasse</a></li>
<li><a class="reference internal" href="#min-e-version">min-e Version</a></li>
<li><a class="reference internal" href="#douglas-peucker-algorithmus">Douglas Peucker Algorithmus</a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  </div>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/notes.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
      
    </div>
  </div>
        <div id="right-column">
          
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="index.html">Docs</a></li>
              
              <li>Mitschriften EDV</li>
            </ol>
          </div>
          
          <div class="document clearer body">
            
  <div class="section" id="mitschriften-edv">
<h1>Mitschriften EDV<a class="headerlink" href="#mitschriften-edv" title="Permalink to this headline">¶</a></h1>
<div class="section" id="table-of-contents">
<h2>Table of Contents<a class="headerlink" href="#table-of-contents" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="#b-fragen">B_Fragen</a></li>
<li><a class="reference internal" href="#c-fragen">C_Fragen</a></li>
<li><a class="reference internal" href="#d-fragen">D_Fragen</a></li>
</ul>
</div>
<div class="section" id="block-b">
<h2>Block B<a class="headerlink" href="#block-b" title="Permalink to this headline">¶</a></h2>
<p>Der Block B beschaeftigt sich mit der Ueberfuehrung einer Szenenbschreibung in
eine bildliche Darstellung.</p>
<p>Daten koennen durch Berechnungen oder Messungen von der Datenquelle erfasst
werden.</p>
<p>Wir untescheiden ferner zwischen 2- und 3d Bilderzeugung</p>
<div class="section" id="pipilines">
<h3>Pipilines<a class="headerlink" href="#pipilines" title="Permalink to this headline">¶</a></h3>
<p>Die Daten durchlaufen einer Pipeline. Diese ist fuer 2D und 3D Modelle
unterschiedlich.</p>
<div class="section" id="d">
<span id="d-pipe"></span><h4>2D<a class="headerlink" href="#d" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li>Transformation</li>
<li>Clipping</li>
<li>Verrasterung</li>
</ol>
</div>
<div class="section" id="id1">
<span id="id2"></span><h4>3D<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li><dl class="first docutils">
<dt>Transformation</dt>
<dd><ul class="first last">
<li>Anwendung einer affinen Abbildung auf die Szene (Szene aus Dreiecken)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Beleuchtung</dt>
<dd><ul class="first last">
<li>Anwendung einer bidirektionelen Shading-Funktion</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Clipping und Projektion</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>(Clipping) Festlegung einer Sehpyramide, deren Inneres den Teil der Szene</dt>
<dd>definiert</dd>
</dl>
</li>
<li>Projektion der dreidimensionalen Szene auf eine zweidimensionale Bildebene</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Sichtbarkeitstrennung</dt>
<dd><ul class="first last">
<li>Entfernen nicht sichtbarer Teile der Szene</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Verrasterung</dt>
<dd><ul class="first last">
<li>Umwandeln der geometrischen Repraesentation in eine Rasterdarstellung</li>
</ul>
</dd>
</dl>
</li>
</ol>
</div>
</div>
<div class="section" id="farben">
<h3>Farben<a class="headerlink" href="#farben" title="Permalink to this headline">¶</a></h3>
<p>Ein Farbsystem besteht aus drei Grundtoenen, um alle vom Menschen wahrnehmbaren
Farben darzustellen.</p>
<div class="section" id="cie">
<h4>CIE<a class="headerlink" href="#cie" title="Permalink to this headline">¶</a></h4>
<p>Commission Internationale de l’Eclairage nutzt drei abstrakte primaerfarben
X,Y,Z. Y entspricht der Lichtstaerke.</p>
</div>
<div class="section" id="rgb">
<h4>RGB<a class="headerlink" href="#rgb" title="Permalink to this headline">¶</a></h4>
<p>Additive darstellung von Farben. Gewichtete Summe von Rot, Gruen, Blau.
p</p>
</div>
<div class="section" id="hsv">
<h4>HSV<a class="headerlink" href="#hsv" title="Permalink to this headline">¶</a></h4>
<p>Hue Saturation Value</p>
<p>Hue in [0,360]</p>
<p>Saturation, Value in [0,1]</p>
</div>
<div class="section" id="cmy">
<h4>CMY<a class="headerlink" href="#cmy" title="Permalink to this headline">¶</a></h4>
<p>Subtraktives Modell von Cyan, Magenta, Yellow</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="d-bilderzeugung">
<h3>2D Bilderzeugung<a class="headerlink" href="#d-bilderzeugung" title="Permalink to this headline">¶</a></h3>
<p>Wir durchlaufen wie bereits bekannt die <a class="reference internal" href="#d-pipe">2d_pipe</a>.</p>
<div class="section" id="koordinatensysteme">
<h4>Koordinatensysteme<a class="headerlink" href="#koordinatensysteme" title="Permalink to this headline">¶</a></h4>
<p>Wir deferenzieren zwischen lokalen und globalen Koordinatensystemen.</p>
<p>Jedes Objekt selbst hat ein lokales koordinatenssystem, jedes Objekt befindet
sich in einem Raum, dem globalen Koordinatensystem</p>
</div>
<div class="section" id="transformationen">
<h4>Transformationen<a class="headerlink" href="#transformationen" title="Permalink to this headline">¶</a></h4>
<p>Wir koennen einen punkt anhand einer affinen Abbildung transformieren.</p>
<div class="math notranslate">
\[p' = A * p + t\]</div>
<p>Dabei ist A eine Matrix fuer Skalierung und Rotation, t ein vektor fuer die
Translation.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Spezialfaelle fuer die affine Abbildung sind:</p>
<p>Translation:</p>
<div class="math notranslate">
\[E*p + t\]</div>
<p>Skalierung:</p>
<div class="math notranslate">
\[((a,0),(0,b)) * p\]</div>
<p>Rotation:</p>
<div class="math notranslate">
\[\begin{split}M_rot * p \\
\text{wobei } M_rot \text{ die Rotationsmatrix ist.}\end{split}\]</div>
<p>Spielgelung:</p>
<div class="math notranslate">
\[\begin{split}E_{mod} * p\\
\text{waagerecht: } e_{22} = -1\\
\text{senkrecht: } e_{11} = -1\\
\text{am Ursprung: } e_{22} = -1 = e_{11}\\\end{split}\]</div>
<p>Scheerung:</p>
<div class="math notranslate">
\[( E + ((0,s_1),(s_2,0)) ) * p\]</div>
</div>
<div class="section" id="transformationsmatrix">
<h4>Transformationsmatrix<a class="headerlink" href="#transformationsmatrix" title="Permalink to this headline">¶</a></h4>
<p>Um alle Transformationen in einer Matrix abdecken zu koennen benutzen wir eine
Transformationsmatrix.</p>
<div class="math notranslate">
\[\begin{split}\begin{array}
    a&amp;b&amp;c\\
    d&amp;e&amp;f\\
    g&amp;h&amp;i
\end{array}\end{split}\]</div>
</div>
<div class="section" id="clipping">
<h4>Clipping<a class="headerlink" href="#clipping" title="Permalink to this headline">¶</a></h4>
<p>Clipping bezeichnet das Abschneiden von Teilen einer Szene die ausserhalb des
definierten Bildbereichs liegen.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>Streckenclipping</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>Algorithmus fuer Clipping</dt>
<dd><ol class="first last arabic">
<li><dl class="first docutils">
<dt>Unterscheide zwischen Punkten, die links/rechts/unterhalb/oberhalb</dt>
<dd>vom Bildbereich liegen.
Entferne alle Kanten, die durch einfache Vergleiche eliminiert
werden koennen</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Wenn die Kante/ Linie von zwei Punkten durch den Bildbereich geht</dt>
<dd>unterteile die Linie in mehrere Linien am Schnittpunkt mit dem
Bildbereich</dd>
</dl>
</li>
</ol>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Durchfuehrung von Schritt 1:</p>
<ul class="simple">
<li>Bitmaske fuer die 8 quadranten um den Bildbereich herum</li>
<li>Verundung muss 0000 sein</li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Durchfuehrung von Schritt 2:</p>
<ul class="simple">
<li>Veroderung muss 0000 sein, schnittpunkte dementsprechend waehlen</li>
</ul>
</div>
<div class="section" id="verrasterung">
<h4>Verrasterung<a class="headerlink" href="#verrasterung" title="Permalink to this headline">¶</a></h4>
<p>Das Problem, mit dem sich die Verrasterung auseinander setzt ist</p>
<p>Der Algorithmus fuer die Verrasterung betrachtet jeweils die x-punkte/pixel
und rundet die y-punkte/pixel auf den naechsten int/ganzzahligen Wert.</p>
</div>
</div>
<div class="section" id="id3">
<h3>3D-Bilderzeugung<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<div class="section" id="transformation">
<h4>Transformation<a class="headerlink" href="#transformation" title="Permalink to this headline">¶</a></h4>
<p>Die Transformationsmatrix bleibt generell gleich, nur das eine weitere
Reihe und spalte hinzugefuegt wird.</p>
</div>
<div class="section" id="beleuchtung">
<h4>Beleuchtung<a class="headerlink" href="#beleuchtung" title="Permalink to this headline">¶</a></h4>
<p>Das Beleuchtungsmodell von Phong besteht aus:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>Ambienten Anteil</dt>
<dd><ul class="first last">
<li>sozusagen ein bias-lichtanteil/ indirekte Beleuchtung</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Diffuser Anteil</dt>
<dd><ul class="first last">
<li>Reflexionen an Materialoberflaeche</li>
<li>Gleichmaessige Reflexion in alle Richtungen</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Glaenzender Anteil</dt>
<dd><ul class="first last">
<li>Gerichtete Reflexion</li>
<li>Abhaengig von Betrachtungspunkt</li>
</ul>
</dd>
</dl>
</li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Es existieren verschiedene shading Modelle</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>Flat Shading</dt>
<dd><ul class="first last">
<li>keien Interpolation, Mittelwerte Fuellen die Flaechen</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Gouraud Shading</dt>
<dd><ul class="first last">
<li>Berechnet Farbwerte an den Eckpunkten der Polygone</li>
<li>lineare Interpolation, gleichmaessiger</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Phong Shading</dt>
<dd><ul class="first last">
<li>Material und Normalattribute an den Eckpunkten</li>
<li>Interpolation der Normalvektoren der Eckpunkte ueber die Flaeche</li>
</ul>
</dd>
</dl>
</li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Textur wird durch eine Rastermatrix vorgegeben</p>
</div>
<div class="section" id="projektion">
<h4>Projektion<a class="headerlink" href="#projektion" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><dl class="first docutils">
<dt>Parrallelprojektion</dt>
<dd><ul class="first last">
<li>eine Bildebene wird durch einen Bildursprung o und zwei koordinaten u, v
definiert</li>
<li>Die Parrallelprojektion ist dann bezueglich einer Richtung w parralle
Projektion der Richtung w auf die Ebene</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>perspetivische Projektion</dt>
<dd><ul class="first last">
<li>zuvor wurden alle Punkte eines Objekts bezueglich einer Richtung w parrallel
auf die Bildebene projeziert</li>
<li>nun wird von einem Augenpunkt aus auf die Ebene Projeziert</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="sichtbarkeitsberechnung">
<h4>Sichtbarkeitsberechnung<a class="headerlink" href="#sichtbarkeitsberechnung" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><dl class="first docutils">
<dt>Szenenbasiert</dt>
<dd><ul class="first last">
<li>Painters Algorithmus/ Binary Space Partitioning</li>
<li>erst Sichtbarkeitsberechnung, dann Verrasterung</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Rasterbasiert</dt>
<dd><ul class="first last">
<li>Tiefenpunktverfahren / Scan-Line / Bereichsunterteilungsverfahren</li>
<li>erst Verrasterung, dann Sichtbarkeitsberechnung</li>
</ul>
</dd>
</dl>
</li>
</ul>
<div class="section" id="moegliche-pruefungsfragen-b">
<span id="b-fragen"></span><h5>Moegliche Pruefungsfragen B<a class="headerlink" href="#moegliche-pruefungsfragen-b" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li><dl class="first docutils">
<dt>Allgemeines zu Farben</dt>
<dd><ul class="first last">
<li>Was sind die aus der VL vorgestellten Farbsysteme?</li>
<li>Warum koennen nicht alle fuer den Menschen sichtbaren Farben effizient
dargestellt werden?</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Allgemeines zur Bilderzeugung</dt>
<dd><ul class="first last">
<li>2D/ 3D Pipeline- Ablauf zeichnen.</li>
<li>Was ist der Unterschied zwischen 2D/ 3D?</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Transformation</dt>
<dd><ul class="first last">
<li>Welche Transformationsarten existieren?</li>
<li>Was benutzen wir in der VL als Mittel um alle Transformationsarten
abzudecken?</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Clipping</dt>
<dd><ul class="first last">
<li>wie wird Clipping durchgefuehrt/ welcher algorithmus?</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Verrasterung</dt>
<dd><ul class="first last">
<li>wie wird Verrasterung durchgefuehrt/ welcher algorithmus?</li>
</ul>
</dd>
</dl>
</li>
<li>3D Tansvormation vs 2D Transformation?</li>
<li>Woraus besteht das vorgestellte 3D-Beleuchtungsmodell?</li>
<li>Welche arten von Shading existieren, welche ist am besten und warum?</li>
<li>Welche Projektionsverfahren existieren, was ist der fundamentale Unterschied?</li>
<li>Welche herangehensweisen existieren zur Sichtbarkeitsberechnung?</li>
</ul>
</div>
</div>
</div>
</div>
<div class="section" id="block-c">
<h2>Block C<a class="headerlink" href="#block-c" title="Permalink to this headline">¶</a></h2>
<p>Generell wird das Problem der Datenerfassung und Reduktion dieser Daten auf das
Wesentliche betrachtet. Dabei sollen Unterschiede der Daten immernoch
ersichtlich bleiben.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Ueber die Dimensionsreduktion wird versucht die Richtungen in einem
hochdimensionalen Raum zu bestimmen, in denne die wesentlichen Strukturen in den
Daten deutlich werden.</p>
<div class="section" id="lagrange-multiplikatoren">
<h3>Lagrange-Multiplikatoren<a class="headerlink" href="#lagrange-multiplikatoren" title="Permalink to this headline">¶</a></h3>
<p>Wir betrachten das Minimierungsproblem von</p>
<div class="math notranslate">
\[\begin{split}f(x,y) - \lambda * g(x,y) = \text{min}\\
g(x,y) = 0\\
\text{mit den partiellen Ableitungen:}\\
f_x - \lambda g_x = 0\\
f_y - \lambda g_y = 0\end{split}\]</div>
<p>Dabei gilt f(x,y) = min unter Nebenbedingung g(x,y) = 0</p>
</div>
<div class="section" id="ausgleichsebenen">
<h3>Ausgleichsebenen<a class="headerlink" href="#ausgleichsebenen" title="Permalink to this headline">¶</a></h3>
<p>Wir suchen eine Hyperebene e* x = d (e:Koeffizienten Vektor, x:Punkt)</p>
<p>Dabei soll die Summe der quadratischen Abstaende der Punkte zur Hyperebene
minimal sein.</p>
<div class="section" id="optmierungsproblem">
<h4>Optmierungsproblem<a class="headerlink" href="#optmierungsproblem" title="Permalink to this headline">¶</a></h4>
<p>f ist die Summe ueber alle Punmkte mal den Koeffizienten Vektor minus dem
Schwerpunkt.</p>
<p>g ist der quadratische Betrag des Koeffizienten Vektor.</p>
<div class="math notranslate">
\[\begin{split}\text{min } f(\ldots) = \Sigma^n_{i=1} (e * a_i - d)^2\\
\text{, wobei } g(\ldots) = ||e||_2^2 = 1\end{split}\]</div>
<p>Dieses Problem kann durch Lagrange Multiplikatoren geloesst werden</p>
</div>
</div>
<div class="section" id="erkenntniss">
<h3>Erkenntniss<a class="headerlink" href="#erkenntniss" title="Permalink to this headline">¶</a></h3>
<p>Damit eine Hyperebene den quadratischen Abstand zu allen Punkten minimiert,
muss sie durch den Schwerpunkt dieser Punkte gehen.</p>
<p>Dadurch erhalten wir eine Vereinfacherung des Problems. So koennen wir die
gegebenen Punkte in den Schwerpunkt verschieben</p>
<p>Dadurch erhalten wir ein neues Verfahren:</p>
<ol class="arabic simple">
<li>Verschieben der Punkte, sodass der Schwerpunkt im Ursprung liegt</li>
<li>Loesen des Problem fuer den Spezialfall, das die Ausgleichsebene durch den
Ursprung geht</li>
<li>Verschiebe die gefundene Loesung in den Urspruenglichen Schwerpunkt</li>
</ol>
<p>Eine Kohonenkarte definiert eine Abbildung eines d-dimensionalen Raums auf
einen k-dimensionalen.
Dabei sollen nachbarschaften moeglichst gut erhalten bleiben.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Im Bereich der Datenvisualisierung wird dabei auf k = 2 oder k = 3 reduziert.</p>
</div>
<div class="section" id="aufbau">
<h3>Aufbau<a class="headerlink" href="#aufbau" title="Permalink to this headline">¶</a></h3>
<p>Die Kohonenkarte besteht aus einem n x m Gitter aus Neuronen. Dabei ist jedem
Neuron ein d-dimensionaler Punkt zugeordnet.</p>
</div>
<div class="section" id="anlernen">
<h3>Anlernen<a class="headerlink" href="#anlernen" title="Permalink to this headline">¶</a></h3>
<p>Initialisiert wird die Kohonenkarte durch das zufaellige Zuordnen der
d-dimensionalen Punkte and die Neuronen.</p>
<p>Die Kohonenkarte wird durch zufaellig gewaehlte Anlerndatenpunkte aus einer
gegebenen Punktmenge angelernt.</p>
</div>
<div class="section" id="vektorquantisierung">
<h3>Vektorquantisierung<a class="headerlink" href="#vektorquantisierung" title="Permalink to this headline">¶</a></h3>
<div class="section" id="k-vektorquantisierung">
<h4>k-Vektorquantisierung<a class="headerlink" href="#k-vektorquantisierung" title="Permalink to this headline">¶</a></h4>
<p>Auffinden von k Punkten, deren raeumliche Verteiliung denen der Gegebenen
Punkte entspricht.</p>
<p>Exakt k Punkte/ Codewords.</p>
</div>
<div class="section" id="id4">
<h4>Vektorquantisierung<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Auffinden von Punkten q, sodass eine disjunkte Zuordnung von maximal p raeumlich
benachbarten Punkten aus der gegebenen Punktmenge zu jedem q existiert.</p>
<p>Unbestimmte Anzahl von Punkten/ Codewords mit je maximal p zugeordneten Punkten.</p>
</div>
<div class="section" id="aufteilung">
<h4>Aufteilung<a class="headerlink" href="#aufteilung" title="Permalink to this headline">¶</a></h4>
<p>Eine AUfteilung kann durch Voronoi-Regionen erfolgen</p>
</div>
</div>
<div class="section" id="hyper-octree-vektorquantisierung">
<h3>Hyper-Octree-Vektorquantisierung<a class="headerlink" href="#hyper-octree-vektorquantisierung" title="Permalink to this headline">¶</a></h3>
<p>Das Bild wird in Quadranten unterteilt. Jeder Quadrant Kann in 4 weitere
Quadranten unterteilt werden, die Kinder des Quadranten werden.
Quadranten werden solange aufgeteilt, bis sie weniger, als p Punkte enthalten.</p>
</div>
<div class="section" id="median-schnitt-vektorquantisierung">
<h3>Median-Schnitt-Vektorquantisierung<a class="headerlink" href="#median-schnitt-vektorquantisierung" title="Permalink to this headline">¶</a></h3>
<p>Ein Baum mit maximal 2 Nachfolgern an jedem Knoten.
Aufteilung erfolgt wie beim Hyper-Octree, <strong>ABER</strong> der Schnitt erfolgt im
Median.</p>
<p>Durch den Median_Schnitt wird eine dichteangepasste Reduktion der gegbenen
Punktmenge erzielt.</p>
<p>Clustering Verfahren sind:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>Partionierende Verfahren</dt>
<dd><ul class="first last">
<li>Paramter: Anzahl k der CLuster, Distanzfunktion</li>
<li>sucht ein flaches Clustering in k Cluster mit minimalen Kosten</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Hierachische Verfahren</dt>
<dd><ul class="first last">
<li>Paramter: Distanzfunktion fuer Punkte und Cluster</li>
<li>bestimmt ein Hierarchie von Clustern</li>
<li>mischt jeweils die aehnlichsten CLuster</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Dichtebasierte Verfahren</dt>
<dd><ul class="first last">
<li>Parameter: minimale Dichte in einem Cluster, Distanzfunktion</li>
<li>erweitert Punkte m ohre Nachbarn, bis die Dichte gross genug ist</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Andere</dt>
<dd><ul class="first last">
<li>Fuzzy, Graph-theoretisch, neuronale Netze</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="k-mittelwert-clustering">
<h3>k-Mittelwert-Clustering<a class="headerlink" href="#k-mittelwert-clustering" title="Permalink to this headline">¶</a></h3>
<p>Man waehlt zufaellig k Clustermittelpunkte</p>
<p>Fortan wird  fuer alle Objekte:</p>
<ul class="simple">
<li>der Abstand jedes Objekts zu jedem Clustermittelpunkt berechnet</li>
<li>Jedes Objekt seinem Clustermittelpunkt zugewiesen</li>
</ul>
<p>Bis sich keine Objektzuordnung mehr aendert, ansonsten wird das Clusterzentrum
neu berechnet</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><ul class="simple">
<li>Das k-Mittelwert-Clustering kann auch als Verfahren zur
k-Vektirquantisierung aufgefasst werden</li>
<li>Die resultierenden Cluster koennen stark von der Wahl der initialen
Centroide abhaengen</li>
<li>Anzahl von Clustern kann auch kleiner als k sein</li>
</ul>
</div></blockquote>
<div class="section" id="moeglichkeiten-zur-verbesserung">
<h4>Moeglichkeiten zur Verbesserung<a class="headerlink" href="#moeglichkeiten-zur-verbesserung" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>mehrere Durchlaeufe mit verschiedenen Starkonfigurationen</li>
<li>abweichende Masse zur Abstands und Centoidbestimmung</li>
<li>initiale Centroide sollten moeglichst weit voneinander entfernt sein</li>
</ul>
</div>
</div>
<div class="section" id="hierarchisches-clustering">
<h3>Hierarchisches CLustering<a class="headerlink" href="#hierarchisches-clustering" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="dichtebasiertes-clustering">
<h3>Dichtebasiertes Clustering<a class="headerlink" href="#dichtebasiertes-clustering" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="block-d">
<h2>Block D<a class="headerlink" href="#block-d" title="Permalink to this headline">¶</a></h2>
<div class="section" id="hypergraph">
<h3>Hypergraph<a class="headerlink" href="#hypergraph" title="Permalink to this headline">¶</a></h3>
<p>Bei einem Hypergraph G = (V,E) ist jedes Element von E eine nicht leere
Teilmenge von V ist.</p>
<p>Jede Kante kann also mehrere Anfangs und Endknoten haben.</p>
<p>Es wurden 4 Ansaetze zum Zeichnen von Graphen vorgestellt:</p>
<ol class="arabic simple">
<li>Topologie-Form-Metrik</li>
<li>Hierarchisch</li>
<li>Sichtbarkeit</li>
<li>Verfeinerung</li>
</ol>
</div>
<div class="section" id="topologie-form-metrik">
<h3>Topologie-Form-Metrik<a class="headerlink" href="#topologie-form-metrik" title="Permalink to this headline">¶</a></h3>
<div class="section" id="topologie">
<h4>Topologie<a class="headerlink" href="#topologie" title="Permalink to this headline">¶</a></h4>
<p>Zwei orthogonle Zeichnungen haben gleiche Topologie, wenn sie durch stetige
Deformation ohne VErtauschen bon Facetten ineinander ueberprueft werden koennen</p>
<p>Dazu benutzen wir Planarisierung</p>
<ul class="simple">
<li>ermitteln des maximalen planaren Untergraphens</li>
<li>Verbleibende Kanten einfuegen mit moeglichst wenig ueberschneidungen</li>
<li>Dummy-Knoten an verbleibenden Uebrschneidungen einfuegen</li>
</ul>
</div>
<div class="section" id="form">
<h4>Form<a class="headerlink" href="#form" title="Permalink to this headline">¶</a></h4>
<p>Zwei orthogonale Zeichnungen haben gleiche Form, wenn sie:</p>
<ol class="arabic simple">
<li>gleiche Topologie haben</li>
<li>eine Zeichnung aus der anderen nur durch Laengenaenderungen der
Liniensegmente hervorgeht</li>
</ol>
<p>Dazu benutzen wir Orthogonalisierung</p>
<ul class="simple">
<li>Knoten ohne Koordinaten</li>
<li>alle Kanfel sind Winkellisten, zur Festlegung ihrer Knicke</li>
<li>Das Ziel ist es die Anzahl von Knicken zu minimieren</li>
</ul>
</div>
<div class="section" id="metrik">
<h4>Metrik<a class="headerlink" href="#metrik" title="Permalink to this headline">¶</a></h4>
<p>Zwei othogonale Zeichnungen haben gleiche Metrik, wenn sie:</p>
<ol class="arabic simple">
<li>kongruent, bzw. durch Verschieben und Drehen ineinander ueberfuehrt werden
koennen</li>
</ol>
<p>Dazu benutzen wir Kompaktifizierung</p>
<ul class="simple">
<li>minimiert die Flaeche des Graphen und legt die Kantenknicke fest</li>
</ul>
</div>
</div>
<div class="section" id="hierachischer-ansatz">
<h3>Hierachischer Ansatz<a class="headerlink" href="#hierachischer-ansatz" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><dl class="first docutils">
<dt>Schichtungsschritt</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>verwandelt einen DAG in einen geschichteten Digraph</dt>
<dd><ul class="first last">
<li>alle Knoten werden einer Schicht unf alle adjazenten Knoten einer
Folgeschicht zugeordnet</li>
</ul>
</dd>
</dl>
</li>
<li>Dummyknoten werden Angefuegt, damit Kanten ueber mehr als eine Schicht
laufen koennen</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Schnittreduzierung</dt>
<dd><ul class="first last">
<li>Minimieren der Anzahl von Kantenschnitten</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Festlegen der x-Koordinaten</dt>
<dd><ul class="first last">
<li>ersetze Dummy-Knoten durch Knicke</li>
</ul>
</dd>
</dl>
</li>
</ol>
<p>(Di-)Graphen enthalten Zyklen, dies erschwert das algorithmische Zeichnen des
Graphens.</p>
<p>Wir verwenden den folgenden Ansatz:
1. Entfernen von Zyklen</p>
<blockquote>
<div><ul class="simple">
<li>die Richtung einiger Kanten wird invertiert um den Graph azyklisch zu
machen</li>
<li>(greedy Algorithmus fuer minimale Rueckwaertskanten)</li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li>Hierarchischer Ansatz</li>
<li>Kanten wieder umrichten</li>
</ol>
</div>
<div class="section" id="sichtbarkeitsansatz">
<h3>Sichtbarkeitsansatz<a class="headerlink" href="#sichtbarkeitsansatz" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>Planarisierung, wie bei Topologie-Form-Metrik-Ansatz</li>
<li><dl class="first docutils">
<dt>Sichtbarkeitsschritt</dt>
<dd><ul class="first last">
<li>jedem Knoten wird ein horizontales Segment zugeordnet</li>
<li><dl class="first docutils">
<dt>jeder Kante wird ein vertikales Segment zugeordnet</dt>
<dd><ul class="first last">
<li>Kantensegmente haben Anfang und Ende in Knotensegmenten</li>
<li>Kantensegmente schneiden einander nicht</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Ersetzungsschritt</dt>
<dd><ul class="first last">
<li>ersetzt jedes horizontale Segment durch einen Punkt</li>
<li>ersetzt jedes vertikale Segment durch eine Polylinie</li>
</ul>
</dd>
</dl>
</li>
</ol>
</div>
<div class="section" id="verfeinerungsansatz">
<h3>Verfeinerungsansatz<a class="headerlink" href="#verfeinerungsansatz" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>Planarisierung, wie bei Topologie-Form-Metrik-Ansatz</li>
<li><dl class="first docutils">
<dt>Verfeinerung</dt>
<dd><ul class="first last">
<li>Alle Facetten haben drei Kanten (Triangulierung)</li>
<li>Qualitaet des Zeichnens maximaler Graphen haengt in der Regel vom
Knotengrad ab</li>
<li>Minimierung des maximalen Knotengrades</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Triangulierungszeichnung</dt>
<dd><ul class="first last">
<li>“Auslegen” aller Dreiecke</li>
<li>entfernen von Dummy-Kanten/Knoten</li>
</ul>
</dd>
</dl>
</li>
</ol>
<p>Beim Schichtweisen Zeichnen von allgemeinen gerichteten Graphen werden Knoten
auf Schichten angeordnet</p>
</div>
<div class="section" id="allgorithmus-von-sugiyama">
<h3>Allgorithmus von Sugiyama<a class="headerlink" href="#allgorithmus-von-sugiyama" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>Entfernen von Zyklen</li>
<li><dl class="first docutils">
<dt>Schichtzuordnung</dt>
<dd><ul class="first last">
<li>y-Koordinaten der Knoten</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Kreuzungsreduktion</dt>
<dd><ul class="first last">
<li>innerhalb der Schichten werden die Knoten so umgeordnet, dass die Anzahl
von Kreuzungen reduziert ist</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>waagerechte Koordinatenzusweisung</dt>
<dd><ul class="first last">
<li>x-Koordinaten der Knoten</li>
</ul>
</dd>
</dl>
</li>
<li>Wiederherstellung der Zyklen</li>
</ol>
</div>
<div class="section" id="einfacher-algorithmus-zum-zeichnen">
<h3>Einfacher Algorithmus zum Zeichnen<a class="headerlink" href="#einfacher-algorithmus-zum-zeichnen" title="Permalink to this headline">¶</a></h3>
<p>wir definieren die Funktionen</p>
<div class="math notranslate">
\[\begin{split}x : V \rightarrow \mathbb{N}\\
x(v) = \text{Index von v im Inorder Durchlauf}\\
y : V \rightarrow \mathbb{N}\\
y(v) = \text{Abstand von v zur Wurzel}\\\end{split}\]</div>
<p>Ueber diese Funktionen erhalten wir die Koordinaten der Knoten</p>
</div>
<div class="section" id="aestetikkriterien-fuer-binaerbaeume">
<h3>Aestetikkriterien fuer Binaerbaeume<a class="headerlink" href="#aestetikkriterien-fuer-binaerbaeume" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>SchichtenZeichnung, die sich am Abstand zur Wurzel orientiert</li>
<li>Linker Kindknoten links und rechter Kindknoten rechts</li>
<li>ElternKnoten ist zntriert ueber seinen Kindern</li>
<li>Zwei Isomorphe Unterbaeume werden gleich gezeichnet</li>
<li>Ein Baum und sein Spiegelbild werden spiegelbildlich gezeichnet</li>
</ol>
<div class="section" id="algorithmus-von-reingold-und-tilford">
<h4>Algorithmus von Reingold und Tilford<a class="headerlink" href="#algorithmus-von-reingold-und-tilford" title="Permalink to this headline">¶</a></h4>
<p>Rekursiv:</p>
<ul class="simple">
<li>Wenn der Baum nur einen Knoten enthaelt wird dieser gezeichnet</li>
<li><dl class="first docutils">
<dt>Sonst:</dt>
<dd><ol class="first last arabic">
<li>Wende den Algorithmus auf den linken und den rechten Unterbaum an</li>
<li><dl class="first docutils">
<dt>Wenn es zwei Kinder gibt, dann:</dt>
<dd><ul class="first last">
<li>Platziere die beiden erhaltenen Zeichnungen der Unterbaeume
in waagerechtem Abstand 2</li>
<li>Platziere die Wurzel des Baums eine Stufer darueber und in der
Mitte zwischen den Kindern</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Sonst:</dt>
<dd><ul class="first last">
<li>platziere die Wurzel in waagerechtem Abstand 1 vom Kind</li>
</ul>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
</li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Erweiterung</p>
<ul class="simple">
<li>Wenn der Baum nur einen Knoten enthaelt wird dieser gezeichnet</li>
<li><dl class="first docutils">
<dt>Sonst:</dt>
<dd><ol class="first last arabic">
<li>Wende den Algorithmus auf den linken und den rechten Unterbaum an</li>
<li><dl class="first docutils">
<dt>Wenn es zwei Kinder gibt, dann:</dt>
<dd><ul class="first last">
<li>Platziere die beiden erhaltenen Zeichnungen der Unterbaeume
in waagerechtem Abstand <strong>1</strong></li>
<li>Platziere die Wurzel des Baums eine Stufer darueber und in der
Mitte zwischen den Kindern</li>
<li><strong>falls der Abstand ungerade ist wird der rechte Unterbaum um 1 nach
rechts geschoben</strong></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Sonst:</dt>
<dd><ul class="first last">
<li>platziere die Wurzel in waagerechtem Abstand 1 vom Kind</li>
</ul>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
</li>
</ul>
<div class="section" id="horizontal-vertikal-zeichnen">
<h5>Horizontal-Vertikal Zeichnen<a class="headerlink" href="#horizontal-vertikal-zeichnen" title="Permalink to this headline">¶</a></h5>
<p>Rekursiv:</p>
<ul class="simple">
<li>Wenn der Baum nur einen Knoten hat, so wird dieser gezeichnet</li>
<li><dl class="first docutils">
<dt>Sonst:</dt>
<dd><ol class="first last arabic">
<li>Wende den Algorithmus auf den linken un rechten Unterbaum an</li>
<li>Zeichne den Teilbaum mit der groesseren Anzahl Knoten rechts und den
Teilbaum mit der kleineren Anzahl KNoten unterhablb der Wurzel</li>
</ol>
</dd>
</dl>
</li>
</ul>
<p>Breite: O(n)</p>
<p>Hoehe: O(log(n))</p>
</div>
<div class="section" id="zeichnen-durch-rekurives-drehen">
<h5>Zeichnen durch rekurives drehen<a class="headerlink" href="#zeichnen-durch-rekurives-drehen" title="Permalink to this headline">¶</a></h5>
<div class="math notranslate">
\[\begin{split}n(G) = |V|\\
l(v) = \text{linkes Kind}\\
r(v) = \text{rechtes Kind}\\\end{split}\]</div>
<ol class="arabic">
<li><dl class="first docutils">
<dt>Fuer jeden Knoten u:</dt>
<dd><ul class="first last simple">
<li>vertausche Kinder so, dass n(l(u)) &lt;= n(r(u))</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">Finde den ersten Knoten v, auf dem an weitesten rechts verlaufenden Weg, fuer
den gilt:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math notranslate">\(n(r(v)) \leq n - (n log(n))^{1/2} &lt; n(v)\)</span></li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Zeichne die linken Unterbaeume auf dem Weg von der Wurzel nach v mit
dem Algorithmus zum horizontal-vertikal Zeichnen</p>
</li>
<li><p class="first">Zeichne die Unterbaeume von v rekursiv</p>
</li>
</ol>
</div>
<div class="section" id="vereinfachen-von-polygonzuegen">
<h5>Vereinfachen von Polygonzuegen<a class="headerlink" href="#vereinfachen-von-polygonzuegen" title="Permalink to this headline">¶</a></h5>
</div>
</div>
</div>
<div class="section" id="min-version">
<h3>min-# Version<a class="headerlink" href="#min-version" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>Konstruiere einen Graphen G(P,:math:<cite>varepsilon</cite>),
der genau dann eine gerichte Kante
<span class="math notranslate">\(p_i, p_j, i&lt;j\)</span> enthaelt, wenn die Abweichung der Strecke zwischen
den Knoten von allen dazwischen liegenden Knoten kleiner als ein Wert
<span class="math notranslate">\(\varepsilon\)</span> ist.</li>
<li>berechen den kuerzesten Weg zwischen dem ersten und letzem Knoten des
Polygonzugs und geben diesen aus</li>
</ol>
</div>
<div class="section" id="fehlermasse">
<h3>Fehlermasse<a class="headerlink" href="#fehlermasse" title="Permalink to this headline">¶</a></h3>
<p>Messen der Abweichungen zwischen einer Strecke <span class="math notranslate">\(p_i, p_j\)</span></p>
<ul class="simple">
<li><dl class="first docutils">
<dt>Punkt-Steckenabstand</dt>
<dd><ul class="first last">
<li>maximaler Abstand zwischen einer Strecke und alle dazwischen liegenden
Punkten</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Punkt Geradenabstand</dt>
<dd><ul class="first last">
<li>maximale Abstande zwischen der Geraden und allen dazwischen liegenden
Punkten</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>streckenausgerichtetes Huellenrechteck</dt>
<dd><ul class="first last">
<li>die Haelfte der Laenge der zur Strecke senkrechten Kanten des
Rechtecks, das laengs der Strecke ausgrichtet ist</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>minimales Huellenrechteck</dt>
<dd><ul class="first last">
<li>die Haelfte der Laenge der kuerzesten Kante des Rechtecks mit kleinster
minimaler KAntenlaenge, dass die zwischenliegenden Punkte mit enthaelt</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="min-e-version">
<h3>min-e Version<a class="headerlink" href="#min-e-version" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>Konstruiere gewichteten gerichteten Graph G(P), der alle gerichtete Kanten
enthaelt, welche die maximalen Abweichung der dazwischen liegenden Punkte als
gewicht haben</li>
<li>Finde durch binaere Suche ueber alle auftretenden Gewichte ein minimales
Gewicht e, sodass ein kuerzester Weg in G(P,e) existiert, der hoechstens
m Knoten</li>
</ol>
</div>
<div class="section" id="douglas-peucker-algorithmus">
<h3>Douglas Peucker Algorithmus<a class="headerlink" href="#douglas-peucker-algorithmus" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Ein Poligonzug P’ besteht initial aus dem ersten und letztem Punkt des
Polygonzugs</li>
<li><dl class="first docutils">
<dt>Es wird der Maximale Abstand aller Punkte zur Strecke ausgerechnet</dt>
<dd><ul class="first last">
<li>Ist dieser groesser als ein vordefiniertes <span class="math notranslate">\(\varepsilon\)</span>
so wird dieser Punkt in die Strecke mit aufgenommen
und der Algorithmus links und recht von diesem Punkt ausgefuehrt</li>
<li>Sonst terminiert die Rekursion</li>
</ul>
</dd>
</dl>
</li>
</ul>
<ul>
<li><p class="first">Was ist ein Hypergraph?</p>
</li>
<li><p class="first">wozu dient Planarisierung und in welchen Algorithmen wird Planarisierung
benutzt?</p>
<blockquote>
<div><ul class="simple">
<li>warum koennen manche Algorithmen auf Planarisierung verzichten?</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">erklaere den Algorithmus von Sugiyama</p>
</li>
<li><p class="first">Weclche Aestethikkriterien werden an das Zeichnen von Baeumen gestellt?</p>
</li>
<li><dl class="first docutils">
<dt>Was ist anders bei der erweiterten Variante von Reingold/ Tilford?</dt>
<dd><ul class="first last simple">
<li>wellcher Nutzen wird daraus gewonnen?</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Nenne 2 weitere Varianten um Graphen moeglichst pltzsparend zu Zeichnen?</dt>
<dd><ul class="first last simple">
<li>Was wurde in der VL gesagt, wo das angewendet wird?</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">Was ist der Unterschied der min-# und der min-e Variante?</p>
</li>
<li><p class="first">Wie verwendet Douglas-Peucker Fehlermasse?</p>
</li>
</ul>
</div>
</div>
</div>


          </div>
            
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="index.html">noname  documentation</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 2018, Max Springenberg. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>